# 分组密码的模式

本章主要介绍了分组密码的模式，包括ECB、CBC、CFB、OFB、CTR。

----

## 分组密码与流密码

**分组密码(block cipher)** 指的是每次只能处理特定长度的一块数据的一类密码算法，**处理完一个分组九结束了，不需要通过内部状态来记录加密的进度**。

**流密码(stream cipher)** 指对数据进行连续处理的一类密码算法。相对于分组密码，流密码在处理过程中 **需要通过内部状态来记录加密的进度**。

----

## 分组密码的模式

分组密码只能加密固定长度的分组，当明文长度大于算法规定的长度时，需要对明文进行分组，进行迭代，以便将一段很长的明文全部加密。

迭代的方法称为分组密码的 **模式(mode)**。

模式有很多种类，主要的模式有：

- **ECB 模式:** Electronic CodeBook mode (电子密码本模式)
- **CBC 模式:** Cipher Block Chaining mode (密码分组链接模式)
- **CFB 模式:** Cipher FeedBack mode (密码反馈模式)
- **OFB 模式:** Output FeedBack mode (输出反馈模式)
- **CTR 模式:** CounTeR mode (计数器模式)

----

### ECB 模式

在 **ECB 模式** 中，将明文分组加密之后的结果直接组装成密文分组，明文分组和密文分组时一一对应的。当最后一个分组长度不够时，需要进行填充(padding)。

#### ECB 模式加解密流程

如下图所示，为 **ECB 模式** 的加密过程：

![4-AES-ECB-Encrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-ECB-Encrypt.png)

解密很简答，直接反过来就OK了：

![4-AES-ECB-Decrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-ECB-Decrypt.png)

#### 针对ECB 模式的攻击

由于各个明文分组都是各自独立地进行加密和解密，所以攻击者可能 **通过改变密文分组的顺序**，从而使得相应的明文分组的顺序也改变。这种攻击方式 **不需要破译密钥就能实现！！！**

Alice要向Bob转账100块，对应的明文分组如下：

```c
明文分组1 = 41 6c 69 63 65 20 20 20 20 20 20 20 20 20 20 20（付款人：Alice）
明文分组2 = 42 6f 62 20 20 20 20 20 20 20 20 20 20 20 20 20（收款人：Bob）
明文分组3 = 31 30 30 20 20 20 20 20 20 20 20 20 20 20 20 20（付款金额：100）
```

假设经过ECB模式加密过后的密文为下面所示。

```c
密文分组1 = dd 85 e0 f1 6c b3 b4 c4 fe 07 0a b7 3f 2c 74 fc（付款人：？？？）
密文分组2 = 2a ea 0d ec b9 64 77 3b fe 86 8c 24 4b 78 82 9a（收款人：？？？）
密文分组3 = 80 9b 16 fc e6 c7 b3 b2 9e 9e 0a a9 76 d1 54 46（付款金额：？？？）
```

攻击者Eve只需要将密文分组 1 和 2 的顺序对调，则结果与实际的结果完全相反！！

```c
密文分组1 = 2a ea 0d ec b9 64 77 3b fe 86 8c 24 4b 78 82 9a（付款人：？？？）
密文分组2 = dd 85 e0 f1 6c b3 b4 c4 fe 07 0a b7 3f 2c 74 fc（收款人：？？？）
密文分组3 = 80 9b 16 fc e6 c7 b3 b2 9e 9e 0a a9 76 d1 54 46（付款金额：？？？）
```

----

### CBC 模式

**CBC 模式** 是将前一个密文分组与下一个明文分组混合起来进行加密的。

#### CBC 模式加解密过程

在加密时，首先将明文分组与上一个密文分组进行 **XOR** 操作，然后再进行加密操作。第一个明文分组进行加密时，需要一个 **初始化向量(Initialization Vector)** 与其进行 **XOR** 操作。

具体加密过程如下所示：

![4-AES-CBC-Encrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CBC-Encrypt.png)

解密流程与加密流程相反。

![4-AES-CBC-Decrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CBC-Decrypt.png)

**CBC 模式** 的特点：

- 明文分组在加密前与前一个密文分组进行 **XOR** 操作，因此，即使相邻的两个明文分组的内容完全一样，所得到的密文分组也 **不一定相等**。
- 无法 **单独对一个明文分组** 进行加密。
- 当 CBC 模式中有 **一个密文分组的内容损坏** ，只要密文分组的长度没有发生变化，则解密时 **最多只会有2个分组** 受到影响。
- 但如果密文分组中有比特缺失，则此后的密文分组解密都将发生错误。

#### 针对CBC 模式的攻击

- 填充提示攻击
- 初始化向量攻击

----

### CFB 模式

**CFB 模式** 是将前一个密文分组进行加密后与明文分组进行 **XOR** 操作得到密文分组。

#### CFB 模式加解密过程

在加密时，首先将上一个密文分组进行加密，然后将得到的机密结果与明文分组进行 **XOR** 操作，得到的结果即为密文分组。第一个密文分组由 **初始化向量(Initialization Vector)** 代替。

具体加密流程如下：

![4-AES-CFB-Encrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CFB-Encrypt.png)

解密过程和 **加密过程一样！** 只不过数据的方向相反。

![4-AES-CFB-Decrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CFB-Decrypt.png)

**CFB 模式** 的特点：

- 在 **CFB 模式** 中，明文分组并没有通过密码算法来直接进行加密。
- 明文分组和密文分组之间只有 **XOR** 操作。
- 在解密时，依然执行的是 **加密操作！** (同一数据异或两次后得到原始数据)

#### 针对CFB 模式的攻击

对 **CFB 模式** 可以实施 **重放攻击(replay attack)**。

Alice向Bob发送了四个分组组成的消息，主动攻击者Eve将后面三个分组的消息保存下来。

Alice第二次向Bob发送了内容不同的，同样也是由四个分组组成的消息，此时，Eve将后面三个分组的消息使用第一次保留的三个分组消息进行替换。

当Bob对第二次接收的消息进行解密时，**分组二** 的消息会 **解密失败**，但 **分组三** 和 **分组四** 的消息都能 **成功解密**。

Bob无法判断消息错误是由通信错误造成的，还是被攻击造成的。

![4-AES-CFB-Replay-Attack](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CFB-Replay-Attack.png)

----

### OFB 模式

在 **OFB 模式** 中，上一次密码算法的输出会作为这次密码算法的输入，产生的结果与明文分组进行 **XOR** 操作，得到对应密文分组。

#### OFB 模式加解密过程

在加密时，首先通过密码算法计算加密后的结果。使用 **密码算法的输出** 和 **明文分组** 进行 **XOR** 操作产生密文分组。密码算法的 **初始输入为初始化向量！！！**

具体流程如下图：

![4-AES-OFB-Encrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-OFB-Encrypt.png)

解密过程和加密过程一样，只不过数据的流向不同。 **密文分组** 和 **密码算法的输出** 作为 **XOR** 操作的对象。

![4-AES-OFB-Decrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-OFB-Decrypt.png)

**OFB 模式** 的特点：

- 明文分组没有通过密码算法直接进行。
- 密码算法的输出结果只与初始化向量有关。
- 密码算法的输出可以先计算出，后续的 **XOR** 操作能够进行并行计算。

#### 针对OFB 模式的攻击

在某个分组中，当密码算法的输入与输出得到相同结果时，后续的分组都将相同的密码算法输出与明文分组进行 **XOR** 操作！！

----

### CTR 模式

**CTR 模式** 是一种通过逐次累加计数器进行加密来生成密钥流的流密码

#### CTR 模式加解密过程

在加密过程中，每个明文分组对应一个逐次累加的计数器，通过对计数器进行加密来生成密钥流。

最终的密文分组是由通过计数器加密后得到的比特序列和明文分组进行 **XOR** 操作得到的。

具体的加密流程如下。

![4-AES-CTR-Encrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CTR-Encrypt.png)

解密过程和加密过程一样，只是数据分组的流向不同。**密文分组** 和 **计数器加密的输出** 作为 **XOR** 操作的对象。

![4-AES-CTR-Decrypt](/Image/Books/ProfessionBooks/图解密码技术/4-AES-CTR-Decrypt.png)

**CTR 模式** 的特点：

- 每次密码算法的输出都不同(前提是保证密码算法的强大性)。
- 可是事先进行密码算法的加密解密操作。
- 加密解密过程可以并行完成。
- 对密文分组中的错误只会出现在对应的明文分组中，错误不会被放大。

## 总结

|模式|名称|优点|缺点|备注|
|:---:|:---|:---|:---|:---|
|ECB模式|Electronic CodeBook mode (电子密码本模式)|1、简单；<br/>2、kuaisu；<br/>3、支持并行计算(加密、解密)|1、明文中的重复排列会反映在密文中；<br/>2、通过删除、替换密文分组对明文进行操作；<br/>3、对包含某些比特错误的密文进行解密时，对应的分组会出错；<br/>4、不能低于重放攻击。|不推荐使用|
|CBC模式|Cipher Block Chaining mode (密码分组链接模式)|1、明文的重复排列不会反应在密文中；<br/>2、支持并行运算(解密)；<br/>3、能够解密任意密文分组。|1、对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错；<br/>2、加密不支持并行计算。|推荐使用|
|CFB模式|Cipher FeedBack mode (密码反馈模式)|1、不需要填充(padding)；<br/>2、支持并行计算(仅解密)；<br/>3、能够揭秘任意密文分组。|1、加密不支持并行计算；<br/>2、对包含某些错误比特的密文进行解密时，第一个分组的相应比特以及后一个分组的全部比特都会出错；<br/>3、不能抵御重放攻击。||
|OFB模式|Output FeedBack mode (输出反馈模式)|1、不需要填充(padding)；<br/>2、可事先进行加密、解密的准备；<br/>3、加密、解密使用相同的结构；<br/>4、对包含某些错误比特的密文进行解密时，只有铭文中的相对应的比特会出错。|1、不支持并行计算；<br/>2、主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转。||
|CTR模式|CounTeR mode (计数器模式)|1、不需要填充(padding)；<br/>2、可事先进行加密、解密的准备；<br/>3、加密、解密使用相同的结构；<br/>4、对包含某些错误比特的密文进行解密时，只有明文中对应的比特会出错；<br/>5、支持并行计算(加密、解密)。|主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转。|推荐使用|
