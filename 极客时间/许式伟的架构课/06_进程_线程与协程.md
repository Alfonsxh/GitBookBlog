# 进程、线程与协程

## 进程和线程

在操作系统中，进程是操作系统中资源调度的最小单位，**每一个可执行程序都是一个进程**，在这个 **主进程** 下面，可以有 **多个子进程或者线程**。

在Linux中，每一个主进程又是属于 **pid为1** 的祖先进程的子进程。操作系统在开机启动时，会启动一个 **pid为0的进程idle**：

- **0号进程** 随后会启动 **pid为1的init进程**。
  - init进程根据Linux操作系统的不同来启动，启动时会在特定的目录下寻找。
  - 现在主流的是 **Systemd** 程序。
  - 如果找不到目标程序，会 **启动sh作为init进程**。
  - 如果连sh都找不到，那么启动失败。
- **0号进程** 还会启动 **pid为2的内核线程处理程序**。
  - 用来管理和回收系统内的进程。

线程是CPU调度的基本单位，每次申请CPU使用都是通过线程来执行的。如果一个程序中只有一个进程在运行，那么它就是它自己的线程。

进程和线程最大的不同在于资源的共享方式。

进程间：

- 对于不同的进程来说，进程间的资源都是隔离的，我们不能通过各自进程中的变量来直接通信。
- 这和操作系统实现的虚拟内存技术相关。
- 每个进程都认为自己是在独立使用操作系统的资源，内存地址也是需要经过映射才能找到对应的物理地址。
- 进程A不能直接访问进程B的内存空间，这是一种安全的做法，要不然病毒程序将会轻易的对计算机进程破坏。
- 进程间可以通过以下方式进程通信：信号、信号量、管道、消息队列、共享内存、socket、文件。
- (todo: 待总结不同方式通信的差异)

线程间:

- 线程间的通信较进程间通信简单了很多。
- 在 **相同的进程内**，多个线程间只需通过公共的变量即可完成信息的交互。
- 在 **不同的进程内**，得使用上面进程间的通信方式。

另外有一点，在Linux中，进程的创建方式——通过 **fork** 的方式创建子进程时，会将父进程的环境变量一起拷贝过来，而子进程似乎不需要所有的，这就造成了很大的资源浪费。虽然现在有了 **写时拷贝** 的方案进行了折中，但是这种方式仍是被人诟病。

## 协程

**协程** 和上面的进程和线程的最大不同在于，协程是在用户的空间，用户控制协程的资源和调度。

（todo: 补充协程内容）