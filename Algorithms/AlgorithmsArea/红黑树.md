# 红黑树

`红黑树(Red–black tree)`是一种[自平衡二叉查找树](https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91)，支持集合、查找、上一元素、下一元素、最大、最小、插入、删除等操作。

**红黑树** 有着最坏情况运行时间，它可以在 **O(logn)** 时间内做查找，插入和删除操作。

**红黑树** 是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。它有以下性质和要求：

- 1.树内的每个节点非红即黑。
- 2.根节点和leaf节点(NIL节点，非叶节点)均为黑色。
- 3.红色节点的子节点均为黑色。
- 4.任一节点到其每个leaf节点的简单路径都包含相同数量的黑色节点。

![Red-black_tree_example](/Image/Algorithms/AlgorithmsArea/Red-Black-Tree/Red-black_tree_example.png)

`红黑树`的每个节点都必须满足上述的条件，其中叶节点的下一层---- **NIL节点**，称之为 **外部节点**，其余的称之为 **内部节点**。

正因为 **红黑树** 拥有上述严格的条件，才能使得其 **插入**、**删除**、**查找**的操作在最坏的情况下的时间复杂度为 **O(logn)**。

## 红黑树修正

在做 **插入** 和 **删除**操作时，可能会违背 **红黑树**的上述规则，这时候需要对红黑树进行修正。

**红黑树**的修正方式有 **变色**、**左旋**、**右旋**。

### 变色

但进行 **插入**或 **删除**操作时，如果违背的规则三，则需要对树内节点进行变换颜色的操作。**黑节点 ---> 红节点**。

### 左旋

进行左旋时，将子树进行逆时针旋转，保证前后的 **先序遍历**结果一致。

具体操作如下：

- 1.将x的左子树赋值给h，作为h的右子树，同时指定x的左子树的父亲节点为h。
- 2.将h的父节点(非空时)赋值给x，同时更新父节点的子节点为x。
- 3.将h的父节点设置为x，x的左子节点设置为h。

![left-rotation](/Image/Algorithms/AlgorithmsArea/Red-Black-Tree/left-rotation.gif)

如上所示，左旋之前子树的 **先序遍历**结果是 **h.left --> h --> x.left --> x --> x.right**。在经过 **左旋**操作后，结果仍是 **h.left --> h --> x.left --> x --> x.right**。

伪代码如下：

```c
x = h.right;

// 1.将x的左子树赋值给h，作为h的右子树，同时指定x的左子树的父亲节点为h。
h.right = x.left;

if(x.left != NIL)
    x.left.parent = h;

// 2.将h的父节点(非空时)赋值给x，同时更新父节点的子节点为x。
x.parent = h.parent;

if(h.parent == NIL)
    root = x;
elif(h == h.parent.left)    // 如果父节点不为NIL，则根据h为左右子树的位置，确定x的位置
    h.parent.left = x;
else
    h.parent.right = x;shan chu

// 3.将h的父节点设置为x，x的左子节点设置为h。
h.parent = x;
x.left = h;
```

### 右旋

右旋的过程和左旋的正好相反。

- 1.将x的右子树赋值给h，作为h的左子树，同时指定x的右子树的父节点为h。
- 2.将h的父节点(非空时)赋值给x，同时更新父节点的子节点为x。
- 3.将h的父节点设置为x，x的右子节点设置为h。

![right-rotation](/Image/Algorithms/AlgorithmsArea/Red-Black-Tree/right-rotation.gif)

伪代码如下：

```c
x = h.right;

// 1.将x的右子树赋值给h，作为h的左子树，同时指定x的右子树的父节点为h。
h.left = x.right;

if(x.right != NIL)
    x.right.parent = h;

// 2.将h的父节点(非空时)赋值给x，同时更新父节点的子节点为x。
x.parent = h.parent;

if(h.parent == NIL)
    root = x;
elif(h.parent.left == h)
    h.parent.left = x;
else
    h.parent.right = x;

// 3.将h的父节点设置为x，x的右子节点设置为h。
h.parent = x
x.right = h
```

## 插入

### 找到插入的位置

首先找到插入的位置，然后针对红黑树的规则条件，对插入位置进行修正。

根据key值，查找插入的位置：

```c++
template<typename T>
void RBTree<T>::insert(Node<T> *&root, Node<T> *node) {
    Node<T> *y = nullptr;
    Node<T> *x = root;

    // 找到插入父节点
    while (x != nullptr) {
        y = x;

        if (node->key > y->key)
            x = x->rightChild;
        else
            x = x->leftChild;
    }
    node->parent = y;

    // 插入
    if (y == nullptr)
        root = node;
    else {
        if (node->key < y->key)
            y->leftChild = node;
        else
            y->rightChild = node;
    }

    node->color = RED;

    // 修正
    this->insertFixUp(root, node);
}

template<typename T>
void RBTree<T>::insert(T key) {
    Node<T> * z = nullptr;

    if ((z = new Node<T>(RED, key, nullptr, nullptr, nullptr)) == nullptr)
        return;

    this->insert(this->m_root, z);
}
```

### 修正

修正需要根据插入点的及其周边点的情况进行修正。

- 如果插入的点为根节点，表示红黑树为空，只需把插入点的颜色修改为红色，然后设置根节点指向插入节点即可。
- 如果插入节点的父节点为黑色，则无需任何操作。
- 如果插入节点的父节点为红色，则需要考虑三种情况：
  - 插入节点的父节点及其父节点的兄弟节点均为红色；
  - 插入节点的父节点为红色，父节点的兄弟节点为黑色，且插入节点为父节点的右孩子；
  - 插入节点的父节点为红色，父节点的兄弟节点为黑色，且插入节点为父节点的左孩子；

对于第一种情况： **插入节点的父节点及其父节点的兄弟节点均为红色**。我们讨论插入节点为左孩子的情况，右孩子类似。

首先 **将父节点及父节点的兄弟节点涂黑，祖父节点涂红**，然后将当前节点指向其祖父节点，以新的节点从新开始判断。如下图所示：

![parent_red_uncle_red](/Image/Algorithms/AlgorithmsArea/Red-Black-Tree/parent_red_uncle_red.png)

对于第二种情况：**插入节点的父节点为红色，父节点的兄弟节点为黑色，且插入节点为父节点的右孩子**。

将当前节点指向其父亲节点，以父亲节点进行 **左旋**。如下图所示：

![parent_red_uncle_black_rightchild](/Image/Algorithms/AlgorithmsArea/Red-Black-Tree/parent_red_uncle_black_rightchild.png)

对于第三种情况：**插入节点的父节点为红色，父节点的兄弟节点为黑色，且插入节点为父节点的左孩子**。

将父节点涂黑，祖父节点涂红，当前节点指向其 **祖父节点**，以 **祖父节点** 进行 **右旋**，并将根结点颜色涂黑。如下图所示：

![parent_red_uncle_black_leftchild](/Image/Algorithms/AlgorithmsArea/Red-Black-Tree/parent_red_uncle_black_leftchild.png)

修正过程始终会走到情况三！步骤可以简单的记为： **变色->左旋->右旋**。

```c++
template<typename T>
void RBTree<T>::insert(Tchild key) {
    Node<T> *z = nullptr;

    if ((z = new Node<T>(RED, key, nullptr, nullptr, nullptr)) == nullptr)
        return;

    this->insert(z);
}

template<typename T>
void RBTree<T>::insert(Node<T> *node) {
    Node<T> *y = nullptr;
    Node<T> *x = this->m_root;

    // 找到插入父节点
    while (x != nullptr) {
        y = x;

        if (node->key > y->key)
            x = x->rightChild;
        else
            x = x->leftChild;
    }
    node->parent = y;

    // 插入
    if (y == nullptr)
        this->m_root = node;
    else {
        if (node->key < y->key)
            y->leftChild = node;
        else
            y->rightChild = node;
    }

    node->color = RED;

    // 修正
    this->insertFixUp(node);
}

template<typename T>
void RBTree<T>::insertFixUp(Node<T> *node) {
    Node<T> *parent, *grandparent;

    while ((parent = node->parent) != nullptr && parent->isred()) {
        grandparent = node->grandParent();  // 这里不可能出现祖父节点为空的情况，因为根结点一定为黑色，所以如果父节点为根节点会跳出循环

        if (parent == grandparent->leftChild) {     // 父节点是祖父节点的左孩子的情况
            Node<T> *uncle = grandparent->rightChild;

            // case1: 父节点和叔父节点都为红色
            if (uncle != nullptr && uncle->isred()) {   // 叔父节点不为空，并且叔父节点为红色
                parent->setblack();     // 将父节点设置为黑色
                uncle->setblack();      // 叔父节点也设置为黑色
                grandparent->setred();  // 祖父节点设置为红色
                node = grandparent;     // 当前节点指向祖父节点
                continue;
            }

            // case2: 叔父节点为黑色，并且当前节点为右孩子
            if (node == parent->rightChild) {
                this->leftRotate(parent);   // 以父节点为中心进行左旋
                Node<T> *tmp = parent;      // 交换当前节点和父节点，为下一步做准备
                parent = node;
                node = tmp;
            }

            // case3: 叔父节点为黑色，并且当前节点为左孩子
            parent->setblack();     // 将父节点设置为黑色
            grandparent->setred();  // 祖父节点设置为红色
            this->rightRotate(grandparent);     // 以祖父节点为中心进行右旋
        } else {    // 父节点是祖父节点的右孩子的情况
            Node<T> *uncle = grandparent->leftChild;

            // case1: 父节点和叔父节点都为红色
            if (uncle != nullptr && uncle->isred()) {   // 叔父节点不为空，并且叔父节点为红色
                parent->setblack();     // 将父节点设置为黑色
                uncle->setblack();      // 叔父节点也设置为黑色
                grandparent->setred();  // 祖父节点设置为红色
                node = grandparent;     // 当前节点指向祖父节点
                continue;
            }

            // case2: 叔父节点为黑色，并且当前节点为左孩子
            if (node == parent->leftChild) {
                this->rightRotate(parent);  // 以父节点为中心进行右旋
                Node<T> *tmp = parent;      // 交换当前节点和父节点，为下一步做准备
                parent = node;
                node = tmp;
            }

            // case3: 叔父节点为黑色，并且当前节点为右孩子
            parent->setblack();     // 将父节点设置为黑色
            grandparent->setred();  // 祖父节点设置为红色
            this->leftRotate(grandparent);      // 以祖父节点为中心进行左旋
        }
    }

    this->m_root->setblack();
}
```

## 删除

（未完，待续）

## 参考

[在线生成红黑树](https://sandbox.runjs.cn/show/2nngvn8w)
[红黑树(四)之 C++的实现](http://www.cnblogs.com/skywang12345/p/3624291.html)(代码不太简洁)
[【数据结构和算法05】 红-黑树](https://blog.csdn.net/eson_15/article/details/51144079) (删除部分缺失)
[红黑树的C++完整实现源码](https://blog.csdn.net/v_JULY_v/article/details/6285620)
[红黑树wiki](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)