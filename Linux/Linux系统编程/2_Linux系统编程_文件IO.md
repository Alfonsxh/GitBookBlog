# 2_Linux系统编程:文件IO

在Linux系统中，一切都是文件！我们可以用操作文件的方式，操作Linux上的一切。文件I/O对于Linux系统来说，非常重要！

## 文件描述符

**文件描述符(File Descriptor)** 是内核为了高效的管理已被打开的文件所创建的索引，**所有执行I/O操作的系统调用都以文件描述符的方式来指代打开的文件**。

文件描述符是一个非负整数，用来表示 **所有类型的已打开文件**，包括 **管道(pipe)、FIFO、socket、终端、设备和普通文件**。

标准的文件描述符包括三个：**标准输入(0)**、**标准输出(1)**、**标准错误(2)**。

| 文件描述符 |   用途   |   POSIX名称   | stdio流 |
| :--------: | :------: | :-----------: | :-----: |
|     0      | 标准输入 | STDIN_FILENO  |  stdin  |
|     1      | 标准输出 | STDOUT_FILENO | stdout  |
|     2      | 标准错误 | STDERR_FILENO | stderr  |

每个进程的文件描述符是有限的，POSIX标准要求每次打开文件时(含socket)必须使用当前进程中最小可用的文件描述符号。在编写需要长期运行并处理大量文件的程序时，比如网络程序，尤其要注意。使用 `ulimit -n` 可以查看当前系统单个进程最大支持的文件描述符数量。

![04_file_descriptor_limit](/Image/Linux/Chapter04/04_file_descriptor_limit.png)

内核维护着三个数据结构来管理文件：

- **进程级的文件描述符表**：含有文件描述符标识，使得用户可以方便的访问一个文件，指向打开文件表的指针用于连接打开文件表。每当进程open一个文件时，会添加一个表项，对同一个文件开打多次就会有多个表项。使用dup系统调用也会添加表项。
- **系统级的打开文件表**：记录了进程对文件的读写偏移，以及进程对文件的存取权限，如进程以O_RDONLY方式打开文件。
- **系统级的i-node表**：包含文件类型，文件所持有的锁的列表指针，以及文件的各种属性，包括大小、不同类型操作相关的时间戳。

![04_file_descriptor](/Image/Linux/Chapter04/04_file_descriptor.png)

- **同一进程的不同文件描述符，可以指向不同的文件，也可以指向相同文件**。如上图中的进程A的1号文件描述符和30号文件描述符，同时指向打开文件表中的23号。
- **不同进程的文件描述符可能相同，但可以指向相同的文件，也可以指向不同文件**。如进程A中的2号和进程B中的2号，同时指向打开文件表中73号，两个进程可能是fork子进程的关系。
- 不同的文件描述符指向同一打开的句柄文件，将共享句柄文件的偏移，换句话说，**如果通过其中一个文件描述符对文件进行了更改，改变了文件的偏移量，那么从另一个文件描述符也能观察到变化**，**不管是不是同一个进程**。

这篇[文章](https://blog.csdn.net/luotuo44/article/details/17474099)讲的比较详细。

// todo：

## 通用文件系统调用

### 打开一个文件: open()

### 读取文件内容: read()

### 数据写入文件: write()

### 关闭文件: close()

### 改变文件偏移量: lseek()

### 

## 参考

- [文件描述符表、文件表、索引结点表](https://blog.csdn.net/luotuo44/article/details/17474099)
- [每天进步一点点——Linux中的文件描述符与打开文件之间的关系](https://blog.csdn.net/cywosp/article/details/38965239)